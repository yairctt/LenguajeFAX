options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(AnalizadorSintactico)
import java.util.*;
import java.io.*;

public class AnalizadorSintactico {
    private static List<ErrorInfo> errores = new ArrayList<>();
    private static Set<String> erroresRegistrados = new HashSet<>();
    
    public static void main(String[] args) throws Exception {
        try {
            AnalizadorSintactico analizador = new AnalizadorSintactico(System.in);
            analizador.Programa();
            
            if (errores.isEmpty()) {
                System.out.println("✓ Compilación exitosa - No se encontraron errores");
            } else {
                System.out.println("✗ Compilación fallida - Se encontraron " + errores.size() + " error(es):\n");
                
                Collections.sort(errores, new Comparator<ErrorInfo>() {
                    public int compare(ErrorInfo e1, ErrorInfo e2) {
                        if (e1.linea != e2.linea) {
                            return Integer.compare(e1.linea, e2.linea);
                        }
                        return Integer.compare(e1.columna, e2.columna);
                    }
                });
                
                for (ErrorInfo error : errores) {
                    System.out.println(error);
                }
                System.out.println("\nTotal de errores: " + errores.size());
            }
            
        } catch (TokenMgrError e) {
            System.out.println("✗ Error léxico:");
            System.out.println(e.getMessage());
            System.exit(1);
        } catch (Exception e) {
            if (!errores.isEmpty()) {
                System.out.println("✗ Compilación fallida - Se encontraron " + errores.size() + " error(es):\n");
                
                Collections.sort(errores, new Comparator<ErrorInfo>() {
                    public int compare(ErrorInfo e1, ErrorInfo e2) {
                        if (e1.linea != e2.linea) {
                            return Integer.compare(e1.linea, e2.linea);
                        }
                        return Integer.compare(e1.columna, e2.columna);
                    }
                });
                
                for (ErrorInfo error : errores) {
                    System.out.println(error);
                }
                System.out.println("\nTotal de errores: " + errores.size());
            } else {
                System.out.println("✗ Error fatal durante la compilación:");
                System.out.println(e.getMessage());
            }
            System.exit(1);
        }
        
        if (!errores.isEmpty()) {
            System.exit(1);
        }
    }
    
    // Registra errores evitando duplicados
    private void agregarError(String tipo, Token t, String descripcion) {
        int lin = t.beginLine;
        int col = t.beginColumn;
        String clave = lin + ":" + col + ":" + descripcion;
        
        if (erroresRegistrados.contains(clave)) {
            return;
        }
        
        erroresRegistrados.add(clave);
        String ubicacion = "Línea " + lin + ", Columna " + col;
        String tokenTexto = "'" + t.image + "'";
        errores.add(new ErrorInfo(tipo, ubicacion, tokenTexto, descripcion, lin, col));
    }
    
    // Avanza hasta encontrar un token de recuperación
    private void avanzarHasta(int[] tokensDeRecuperacion) {
        Token actual;
        while (true) {
            actual = getToken(1);
            if (actual.kind == EOF) return;
            
            for (int tok : tokensDeRecuperacion) {
                if (actual.kind == tok) {
                    return;
                }
            }
            getNextToken();
        }
    }
    
    // Verifica si el siguiente token es el esperado, si no reporta error pero continúa
    private void esperarToken(int tipoEsperado, String nombreToken) {
        Token siguiente = getToken(1);
        if (siguiente.kind != tipoEsperado) {
            agregarError("ERROR_SINTACTICO", siguiente, "Se esperaba " + nombreToken);
        } else {
            getNextToken();
        }
    }
}

class ErrorInfo {
    String tipo;
    String donde;
    String cual;
    String solucion;
    int linea;
    int columna;
    
    ErrorInfo(String tipo, String donde, String cual, String solucion, int linea, int columna) {
        this.tipo = tipo;
        this.donde = donde;
        this.cual = cual;
        this.solucion = solucion;
        this.linea = linea;
        this.columna = columna;
    }
    
    @Override
    public String toString() {
        return donde + ": " + tipo.replace("_", " ") + " " + cual + " - " + solucion;
    }
}

PARSER_END(AnalizadorSintactico)

/* ========================
    Definición de TOKENS
    ======================== */

TOKEN: { <ENTERO: "entero"> }
TOKEN: { <REAL: "real"> }
TOKEN: { <CADENA_T: "cadena"> }
TOKEN: { <LOGICO: "logico"> }
TOKEN: { <VERDADERO: "verdadero"> }
TOKEN: { <FALSO: "falso"> }

TOKEN: { <LEER: "leer"> }
TOKEN: { <ESCRIBIR: "escribir"> }

TOKEN: { <SI: "si"> }
TOKEN: { <SINO: "sino"> }
TOKEN: { <ENTONCES: "entonces"> }

TOKEN: { <MIENTRAS: "mientras"> }
TOKEN: { <PARA: "para"> }
TOKEN: { <HACER: "hacer"> }

TOKEN: { <INICIO: "inicio"> }
TOKEN: { <FIN: "fin"> }
TOKEN: { <FUNCION: "funcion"> }
TOKEN: { <RETORNAR: "retornar"> }

TOKEN: { <AND: "&&"> }
TOKEN: { <OR: "||"> }
TOKEN: { <NOT: "!"> }

TOKEN: { <SUMA: "+"> }
TOKEN: { <RESTA: "-"> }
TOKEN: { <MULTIPLICA: "*"> }
TOKEN: { <DIVIDE: "/"> }

TOKEN: { <MENOR_IGUAL: "<="> }
TOKEN: { <MAYOR_IGUAL: ">="> }
TOKEN: { <DIFERENTE: "!="> }
TOKEN: { <IGUAL: "=="> }
TOKEN: { <MENOR: "<"> }
TOKEN: { <MAYOR: ">"> }

TOKEN: { <ASIG: "="> }

TOKEN: { <PAR_ABRE: "("> }
TOKEN: { <PAR_CIERRA: ")"> }
TOKEN: { <COR_ABRE: "["> }
TOKEN: { <COR_CIERRA: "]"> }
TOKEN: { <LLAVE_ABRE: "{"> }
TOKEN: { <LLAVE_CIERRA: "}"> }
TOKEN: { <PUNTO_COMA: ";"> }
TOKEN: { <COMA: ","> }
TOKEN: { <PUNTO: "."> }
TOKEN: { <DOS_PUNTOS: ":"> }

TOKEN: { <NUM_REAL: (["0"-"9"])+ "." (["0"-"9"])+> }
TOKEN: { <NUM_ENTERO: (["0"-"9"])+> }

TOKEN: { <CADENA: "\"" (~["\""])* "\""> }

TOKEN: { <ID: (["a"-"z","A"-"Z","_"])(["a"-"z","A"-"Z","0"-"9","_"])*> }

SKIP: { " " | "\t" | "\r" | "\n" }

/* ========================
    REGLAS SINTÁCTICAS
    ======================== */

void Programa() :
{
    Token t;
    boolean tokenInesperadoAntesDelFin = false;
}
{
    try {
        <INICIO>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "El programa debe iniciar con 'inicio'");
        avanzarHasta(new int[]{ENTERO, REAL, CADENA_T, LOGICO, ID, SI, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR, FIN});
    }
    
    (
        LOOKAHEAD({getToken(1).kind != FIN && getToken(1).kind != EOF})
        CodigoOError()
    )*
    
    {
        t = getToken(1);
        if (t.kind != FIN && t.kind != EOF) {
            // Hay un token antes de FIN que no se procesó correctamente
            agregarError("ERROR_SINTÁCTICO", t, 
                        "Token inesperado, se esperaba 'fin'");
            tokenInesperadoAntesDelFin = true;
            // Consumir todos los tokens hasta FIN o EOF
            while (t.kind != FIN && t.kind != EOF) {
                t = getNextToken();
                if (getToken(1).kind == FIN || getToken(1).kind == EOF) {
                    break;
                }
            }
        }
    }
    
    try {
        <FIN>
    } catch (ParseException e) {
        // Solo reportar si no hubo un token inesperado antes
        if (!tokenInesperadoAntesDelFin) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "El programa debe finalizar con 'fin'");
        }
    }
    
    <EOF>
}

void CodigoOError() :
{
    Token t;
}
{
    try {
        (
            LOOKAHEAD(TipoDato() <ID>)
            Declaracion()
            |
            LOOKAHEAD(2)
            Sentencia()
        )
    } catch (ParseException e) {
        // Si falla, verificar qué tipo de token es
        t = getToken(1);
        if (t.kind != EOF && t.kind != FIN) {
            t = getNextToken();
            agregarError("ERROR_SINTÁCTICO", t, 
                        "Token inesperado, se esperaba una declaración o sentencia");
            avanzarHasta(new int[]{PUNTO_COMA, ENTERO, REAL, CADENA_T, LOGICO, ID, SI, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR, FIN});
            if (getToken(1).kind == PUNTO_COMA) {
                getNextToken();
            }
        }
    }
}

void Declaracion() :
{
    Token tipo, id, siguiente;
}
{
    tipo = TipoDato()
    
    try {
        id = <ID>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Falta identificador tras el tipo de dato");
        avanzarHasta(new int[]{PUNTO_COMA, ASIG});
    }
    
    (
        <ASIG>
        try {
            Expresion()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Expresión de asignación incorrecta");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
    )?
    
    {
        siguiente = getToken(1);
        if (siguiente.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", siguiente, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

Token TipoDato() :
{
    Token t;
}
{
    (
        t = <ENTERO> | t = <REAL> | t = <CADENA_T> | t = <LOGICO>
    )
    { return t; }
}

void Sentencia() :
{}
{
    try {
        (
            LOOKAHEAD(2) Asignacion()
            | LOOKAHEAD(2) LecturaEscritura()
            | LOOKAHEAD(2) Condicional()
            | LOOKAHEAD(2) Ciclo()
            | LOOKAHEAD(2) Retorno()
        )
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Sentencia no reconocida");
        avanzarHasta(new int[]{PUNTO_COMA, LLAVE_CIERRA, ID, SI, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR});
        if (getToken(1).kind == PUNTO_COMA) {
            getNextToken();
        }
    }
}

void Asignacion() :
{
    Token id, sig;
}
{
    id = <ID>
    
    try {
        <ASIG>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Se requiere operador de asignación (=)");
        avanzarHasta(new int[]{PUNTO_COMA, NUM_ENTERO, NUM_REAL, CADENA, ID, PAR_ABRE});
    }
    
    try {
        Expresion()
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Expresión inválida en asignación");
        avanzarHasta(new int[]{PUNTO_COMA});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

void LecturaEscritura() :
{
    Token sig;
}
{
    (
        <LEER>
        try {
            <PAR_ABRE>
            <ID>
            <PAR_CIERRA>
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Formato incorrecto: debe ser leer(variable);");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
        
        {
            sig = getToken(1);
            if (sig.kind != PUNTO_COMA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
            } else {
                getNextToken();
            }
        }
    )
    |
    (
        <ESCRIBIR>
        try {
            <PAR_ABRE>
            Expresion()
            ( <COMA> Expresion() )*
            <PAR_CIERRA>
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en sintaxis de 'escribir'");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
        
        {
            sig = getToken(1);
            if (sig.kind != PUNTO_COMA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
            } else {
                getNextToken();
            }
        }
    )
}

void Condicional() :
{
    Token sig;
}
{
    <SI>
    
    try {
        <PAR_ABRE>
        ExpresionLogica()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Condición mal formada en 'si'");
        avanzarHasta(new int[]{ENTONCES, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != ENTONCES) {
            agregarError("ERROR_SINTÁCTICO", sig, "Falta 'entonces' tras la condición");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD(2)
        <SINO>
        
        {
            sig = getToken(1);
            if (sig.kind != LLAVE_ABRE) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
            } else {
                getNextToken();
            }
        }
        
        (
            LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
            Sentencia()
        )*
        
        {
            sig = getToken(1);
            if (sig.kind != LLAVE_CIERRA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
            } else {
                getNextToken();
            }
        }
    )?
}

void Ciclo() :
{}
{
    CicloMientras()
    | CicloPara()
}

void CicloMientras() :
{
    Token sig;
}
{
    <MIENTRAS>
    
    try {
        <PAR_ABRE>
        ExpresionLogica()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Condición incorrecta en 'mientras'");
        avanzarHasta(new int[]{HACER, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != HACER) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba 'hacer'");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
}

void CicloPara() :
{
    Token sig;
}
{
    <PARA>
    
    try {
        <PAR_ABRE>
        <ID> <ASIG> Expresion() <PUNTO_COMA>
        ExpresionLogica() <PUNTO_COMA>
        <ID> <ASIG> Expresion()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Estructura incorrecta en ciclo 'para'");
        avanzarHasta(new int[]{HACER, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != HACER) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba 'hacer'");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
}

void Retorno() :
{
    Token sig;
}
{
    <RETORNAR>
    
    try {
        Expresion()
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Expresión de retorno inválida");
        avanzarHasta(new int[]{PUNTO_COMA});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

void Expresion() :
{}
{
    ExpresionLogica()
}

void ExpresionLogica() :
{}
{
    ExpresionRelacional()
    (
        (<AND> | <OR>)
        try {
            ExpresionRelacional()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en operación lógica");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA});
        }
    )*
}

void ExpresionRelacional() :
{}
{
    ExpresionAritmetica()
    (
        (<MENOR> | <MAYOR> | <MENOR_IGUAL> | <MAYOR_IGUAL> | <IGUAL> | <DIFERENTE>)
        try {
            ExpresionAritmetica()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en comparación");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, AND, OR});
        }
    )?
}

void ExpresionAritmetica() :
{}
{
    Termino()
    (
        (<SUMA> | <RESTA>)
        try {
            Termino()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en operación aritmética");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA});
        }
    )*
}

void Termino() :
{}
{
    Factor()
    (
        (<MULTIPLICA> | <DIVIDE>)
        try {
            Factor()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en multiplicación/división");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, SUMA, RESTA});
        }
    )*
}

void Factor() :
{}
{
    try {
        (
            <NUM_ENTERO>
            | <NUM_REAL>
            | <CADENA>
            | <VERDADERO>
            | <FALSO>
            | <ID>
            | <PAR_ABRE> Expresion() <PAR_CIERRA>
            | <NOT> Factor()
        )
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Factor no válido");
        avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, SUMA, RESTA, MULTIPLICA, DIVIDE});
    }
}