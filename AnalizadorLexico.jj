options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(AnalizadorLexico)
import java.util.*;
import java.io.*;

public class AnalizadorLexico {
    private static List<TokenInfo> tokensEncontrados = new ArrayList<>();
    private static List<ErrorLexico> errores = new ArrayList<>();
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== LENGUAJE FAX - FASE LEXICA ===\n");
        
        try {
            AnalizadorLexico analizador = new AnalizadorLexico(System.in);
            analizador.analizarTodo();
            
            if (errores.isEmpty()) {
                System.out.println("FASE LEXICA: Completada correctamente\n");
                mostrarEstadisticas();
            } else {
                System.out.println("FASE LEXICA: ERRORES ENCONTRADOS\n");
                for (ErrorLexico error : errores) {
                    System.out.println(error);
                }
                System.out.println();
                mostrarEstadisticas();
                System.exit(1);
            }
            
        } catch (Exception e) {
            System.out.println("FASE LEXICA: ERROR FATAL\n");
            System.out.println("Tipo: ERROR DESCONOCIDO");
            System.out.println("Detalles: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    public void analizarTodo() {
        Token token;
        while (true) {
            try {
                token = getNextToken();
                if (token.kind == AnalizadorLexicoConstants.EOF) {
                    break;
                }
                registrarToken(token);
            } catch (TokenMgrError e) {
                manejarErrorLexico(e);
                try {
                    token_source.input_stream.readChar();
                } catch (Exception ex) {
                    break;
                }
            }
        }
    }
    
    private void manejarErrorLexico(TokenMgrError e) {
        String mensaje = e.getMessage();
        int linea = 0;
        int columna = 0;
        
        if (mensaje.contains("line ")) {
            try {
                int lineaIndex = mensaje.indexOf("line ") + 5;
                int comaIndex = mensaje.indexOf(",", lineaIndex);
                linea = Integer.parseInt(mensaje.substring(lineaIndex, comaIndex).trim());
                
                int columnaIndex = mensaje.indexOf("column ") + 7;
                int puntoIndex = mensaje.indexOf(".", columnaIndex);
                columna = Integer.parseInt(mensaje.substring(columnaIndex, puntoIndex).trim());
            } catch (Exception ex) {
                // Si no podemos extraer la posición, usamos valores por defecto
            }
        }
        
        String caracterProblematico = "";
        if (mensaje.contains("Encountered: ")) {
            int encuentroIndex = mensaje.indexOf("Encountered: ") + 13;
            int parentesisIndex = mensaje.indexOf(" (", encuentroIndex);
            if (parentesisIndex > encuentroIndex) {
                caracterProblematico = mensaje.substring(encuentroIndex, parentesisIndex).trim();
            }
        }
        
        String mensajeError = "Token no reconocido: " + caracterProblematico;
        errores.add(new ErrorLexico(mensajeError, linea, columna));
    }
    
    public static void registrarToken(Token token) {
        String tipo = obtenerTipoPorKind(token.kind, token.image);
        String lexema = token.image;
        tokensEncontrados.add(new TokenInfo(tipo, lexema, token.beginLine, token.beginColumn));
    }
    
    private static String obtenerTipoPorKind(int kind, String lexema) {
        switch(kind) {
            // Tipos de datos
            case AnalizadorLexicoConstants.ENTERO:
            case AnalizadorLexicoConstants.REAL:
            case AnalizadorLexicoConstants.CADENA_T:
            case AnalizadorLexicoConstants.LOGICO:
                return "PALABRA_RESERVADA_TIPO";
            
            // Literales booleanos
            case AnalizadorLexicoConstants.VERDADERO:
            case AnalizadorLexicoConstants.FALSO:
                return "LITERAL_BOOLEANO";
            
            // E/S
            case AnalizadorLexicoConstants.LEER:
            case AnalizadorLexicoConstants.ESCRIBIR:
                return "PALABRA_RESERVADA_E_S";
            
            // Condicionales
            case AnalizadorLexicoConstants.SI:
            case AnalizadorLexicoConstants.SINO:
            case AnalizadorLexicoConstants.ENTONCES:
                return "PALABRA_RESERVADA_CONDICIONAL";
            
            // Ciclos
            case AnalizadorLexicoConstants.MIENTRAS:
            case AnalizadorLexicoConstants.PARA:
            case AnalizadorLexicoConstants.HACER:
                return "PALABRA_RESERVADA_CICLO";
            
            // Control
            case AnalizadorLexicoConstants.INICIO:
            case AnalizadorLexicoConstants.FIN:
            case AnalizadorLexicoConstants.FUNCION:
            case AnalizadorLexicoConstants.RETORNAR:
                return "PALABRA_RESERVADA_CONTROL";
            
            // Operadores lógicos
            case AnalizadorLexicoConstants.AND:
            case AnalizadorLexicoConstants.OR:
            case AnalizadorLexicoConstants.NOT:
                return "OPERADOR_LOGICO";
            
            // Operadores aritméticos
            case AnalizadorLexicoConstants.SUMA:
            case AnalizadorLexicoConstants.RESTA:
            case AnalizadorLexicoConstants.MULTIPLICA:
            case AnalizadorLexicoConstants.DIVIDE:
                return "OPERADOR_ARITMETICO";
            
            // Operadores relacionales
            case AnalizadorLexicoConstants.MENOR:
            case AnalizadorLexicoConstants.MAYOR:
            case AnalizadorLexicoConstants.MENOR_IGUAL:
            case AnalizadorLexicoConstants.MAYOR_IGUAL:
            case AnalizadorLexicoConstants.IGUAL:
            case AnalizadorLexicoConstants.DIFERENTE:
                return "OPERADOR_RELACIONAL";
            
            // Asignación
            case AnalizadorLexicoConstants.ASIG:
                return "OPERADOR_ASIGNACION";
            
            // Números
            case AnalizadorLexicoConstants.NUM_ENTERO:
                return "LITERAL_ENTERO";
            
            case AnalizadorLexicoConstants.NUM_REAL:
                return "LITERAL_REAL";
            
            // Cadenas
            case AnalizadorLexicoConstants.CADENA:
                return "LITERAL_CADENA";
            
            // Símbolos
            case AnalizadorLexicoConstants.PAR_ABRE:
            case AnalizadorLexicoConstants.PAR_CIERRA:
                return "DELIMITADOR_PARENTESIS";
            
            case AnalizadorLexicoConstants.COR_ABRE:
            case AnalizadorLexicoConstants.COR_CIERRA:
                return "DELIMITADOR_CORCHETE";
            
            case AnalizadorLexicoConstants.LLAVE_ABRE:
            case AnalizadorLexicoConstants.LLAVE_CIERRA:
                return "DELIMITADOR_LLAVE";
            
            case AnalizadorLexicoConstants.PUNTO_COMA:
                return "SEPARADOR_PUNTO_COMA";
            
            case AnalizadorLexicoConstants.COMA:
                return "SEPARADOR_COMA";
            
            case AnalizadorLexicoConstants.PUNTO:
                return "SEPARADOR_PUNTO";
            
            case AnalizadorLexicoConstants.DOS_PUNTOS:
                return "SEPARADOR_DOS_PUNTOS";
            
            // Identificadores
            case AnalizadorLexicoConstants.ID:
                return "IDENTIFICADOR";
            
            default:
                return "DESCONOCIDO";
        }
    }
    
    private static void mostrarEstadisticas() {
        Map<String, Integer> estadisticas = new HashMap<>();
        for (TokenInfo t : tokensEncontrados) {
            estadisticas.put(t.tipo, estadisticas.getOrDefault(t.tipo, 0) + 1);
        }
        
        System.out.println("Total de tokens validos: " + tokensEncontrados.size());
        System.out.println("Total de errores: " + errores.size());
        
        if (!estadisticas.isEmpty()) {
            System.out.println("\nTipo de Token:");
            System.out.println("  " + "=".repeat(50));
            
            // Ordenar por nombre de categoría
            List<String> categorias = new ArrayList<>(estadisticas.keySet());
            Collections.sort(categorias);
            
            for (String categoria : categorias) {
                System.out.printf("  %-30s : %3d\n", categoria, estadisticas.get(categoria));
            }
            System.out.println("  " + "=".repeat(50));
        }
    }
    
    private static void mostrarTokens() {
        if (tokensEncontrados.isEmpty()) {
            System.out.println("No se encontraron tokens\n");
        } else {
            System.out.println("=== TOKENS IDENTIFICADOS ===\n");
            System.out.printf("%-4s %-30s %-20s %s\n", "Nº", "Categoria", "Lexema", "Posicion");
            System.out.println("=".repeat(80));
            
            for (int i = 0; i < tokensEncontrados.size(); i++) {
                TokenInfo t = tokensEncontrados.get(i);
                System.out.printf("%-4d %-30s %-20s L:%d C:%d\n", 
                    (i+1), t.tipo, t.lexema, t.linea, t.columna);
            }
            System.out.println("=".repeat(80));
            System.out.println("Total: " + tokensEncontrados.size() + " tokens\n");
        }
    }
}

class TokenInfo {
    String tipo;
    String lexema;
    int linea;
    int columna;
    
    TokenInfo(String tipo, String lexema, int linea, int columna) {
        this.tipo = tipo;
        this.lexema = lexema;
        this.linea = linea;
        this.columna = columna;
    }
}

class ErrorLexico {
    String mensaje;
    int linea;
    int columna;
    
    ErrorLexico(String mensaje, int linea, int columna) {
        this.mensaje = mensaje;
        this.linea = linea;
        this.columna = columna;
    }
    
    @Override
    public String toString() {
        return String.format("  Linea %d, Columna %d: %s", linea, columna, mensaje);
    }
}

PARSER_END(AnalizadorLexico)

/* ========================
   Definición de TOKENS
   ======================== */

// ===== PALABRAS RESERVADAS =====

// Tipos de datos
TOKEN: { <ENTERO: "entero"> }
TOKEN: { <REAL: "real"> }
TOKEN: { <CADENA_T: "cadena"> }
TOKEN: { <LOGICO: "logico"> }
TOKEN: { <VERDADERO: "verdadero"> }
TOKEN: { <FALSO: "falso"> }

// E/S
TOKEN: { <LEER: "leer"> }
TOKEN: { <ESCRIBIR: "escribir"> }

// Condicionales
TOKEN: { <SI: "si"> }
TOKEN: { <SINO: "sino"> }
TOKEN: { <ENTONCES: "entonces"> }

// Ciclos
TOKEN: { <MIENTRAS: "mientras"> }
TOKEN: { <PARA: "para"> }
TOKEN: { <HACER: "hacer"> }

// Control
TOKEN: { <INICIO: "inicio"> }
TOKEN: { <FIN: "fin"> }
TOKEN: { <FUNCION: "funcion"> }
TOKEN: { <RETORNAR: "retornar"> }

// ===== OPERADORES LÓGICOS =====
TOKEN: { <AND: "y"> }
TOKEN: { <OR: "o"> }
TOKEN: { <NOT: "no"> }

// ===== OPERADORES ARITMÉTICOS =====
TOKEN: { <SUMA: "+"> }
TOKEN: { <RESTA: "-"> }
TOKEN: { <MULTIPLICA: "*"> }
TOKEN: { <DIVIDE: "/"> }

// ===== OPERADORES RELACIONALES =====
TOKEN: { <MENOR_IGUAL: "<="> }
TOKEN: { <MAYOR_IGUAL: ">="> }
TOKEN: { <DIFERENTE: "<>"> }
TOKEN: { <IGUAL: "=="> }
TOKEN: { <MENOR: "<"> }
TOKEN: { <MAYOR: ">"> }

// ===== OPERADOR DE ASIGNACIÓN =====
TOKEN: { <ASIG: "="> }

// ===== SÍMBOLOS ESPECIALES =====
TOKEN: { <PAR_ABRE: "("> }
TOKEN: { <PAR_CIERRA: ")"> }
TOKEN: { <COR_ABRE: "["> }
TOKEN: { <COR_CIERRA: "]"> }
TOKEN: { <LLAVE_ABRE: "{"> }
TOKEN: { <LLAVE_CIERRA: "}"> }
TOKEN: { <PUNTO_COMA: ";"> }
TOKEN: { <COMA: ","> }
TOKEN: { <PUNTO: "."> }
TOKEN: { <DOS_PUNTOS: ":"> }

// ===== NÚMEROS =====
TOKEN: { <NUM_REAL: (["0"-"9"])+ "." (["0"-"9"])+> }
TOKEN: { <NUM_ENTERO: (["0"-"9"])+> }

// ===== CADENAS =====
TOKEN: { <CADENA: "\"" (~["\""])* "\""> }

// ===== IDENTIFICADORES =====
TOKEN: { <ID: (["a"-"z","A"-"Z","_"])(["a"-"z","A"-"Z","0"-"9","_"])*> }

// ===== ESPACIOS EN BLANCO =====
SKIP: { " " | "\t" | "\r" | "\n" }

/* ========================
   Regla Principal (Dummy)
   ======================== */

void Programa() :
{}
{
    <EOF>
}