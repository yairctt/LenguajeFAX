options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(Fax)
import java.util.*;
import java.io.*;

public class Fax {
    private static List<ErrorInfo> errores = new ArrayList<>();
    private static Set<String> erroresRegistrados = new HashSet<>();
    private static boolean continuarAnalizando = true;
    
    public static void main(String[] args) throws Exception {
    System.out.println("Iniciando compilación...\n");
        try {
            Fax analizador = new Fax(System.in);
            analizador.Programa();
            
            if (errores.isEmpty()) {
                System.out.println("✓ Compilación exitosa - No se encontraron errores");
            } else {
                System.out.println("✗ Compilación fallida - Se encontraron " + errores.size() + " error(es):\n");
                
                Collections.sort(errores, new Comparator<ErrorInfo>() {
                    public int compare(ErrorInfo e1, ErrorInfo e2) {
                        if (e1.linea != e2.linea) {
                            return Integer.compare(e1.linea, e2.linea);
                        }
                        return Integer.compare(e1.columna, e2.columna);
                    }
                });
                
                for (ErrorInfo error : errores) {
                    System.out.println(error);
                }
                System.out.println("\nTotal de errores: " + errores.size());
            }
            
        } catch (TokenMgrError e) {
            // Los caracteres inválidos ya fueron registrados, continuar si hay errores
            if (!errores.isEmpty()) {
                System.out.println("✗ Compilación fallida - Se encontraron " + errores.size() + " error(es):\n");
                
                Collections.sort(errores, new Comparator<ErrorInfo>() {
                    public int compare(ErrorInfo e1, ErrorInfo e2) {
                        if (e1.linea != e2.linea) {
                            return Integer.compare(e1.linea, e2.linea);
                        }
                        return Integer.compare(e1.columna, e2.columna);
                    }
                });
                
                for (ErrorInfo error : errores) {
                    System.out.println(error);
                }
                System.out.println("\nTotal de errores: " + errores.size());
            } else {
                System.out.println("✗ Error léxico fatal:");
                System.out.println(e.getMessage());
            }
            System.exit(1);
        } catch (Exception e) {
            if (!errores.isEmpty()) {
                System.out.println("✗ Compilación fallida - Se encontraron " + errores.size() + " error(es):\n");
                
                Collections.sort(errores, new Comparator<ErrorInfo>() {
                    public int compare(ErrorInfo e1, ErrorInfo e2) {
                        if (e1.linea != e2.linea) {
                            return Integer.compare(e1.linea, e2.linea);
                        }
                        return Integer.compare(e1.columna, e2.columna);
                    }
                });
                
                for (ErrorInfo error : errores) {
                    System.out.println(error);
                }
                System.out.println("\nTotal de errores: " + errores.size());
            } else {
                System.out.println("✗ Error fatal durante la compilación:");
                System.out.println(e.getMessage());
            }
            System.exit(1);
        }
        
        if (!errores.isEmpty()) {
            System.exit(1);
        }
    }
    
    private void agregarError(String tipo, Token t, String descripcion) {
        int lin = t.beginLine;
        int col = t.beginColumn;
        String clave = lin + ":" + col + ":" + descripcion;
        
        if (erroresRegistrados.contains(clave)) {
            return;
        }
        
        erroresRegistrados.add(clave);
        String ubicacion = "Línea " + lin + ", Columna " + col;
        String tokenTexto = "'" + t.image + "'";
        errores.add(new ErrorInfo(tipo, ubicacion, tokenTexto, descripcion, lin, col));
    }
    
    public static void agregarErrorLexico(int linea, int columna, String caracter) {
        String clave = linea + ":" + columna + ":Carácter inválido";
        
        if (erroresRegistrados.contains(clave)) {
            return;
        }
        
        erroresRegistrados.add(clave);
        String ubicacion = "Línea " + linea + ", Columna " + columna;
        String tokenTexto = "'" + caracter + "'";
        errores.add(new ErrorInfo("ERROR_LÉXICO", ubicacion, tokenTexto, "Carácter no reconocido", linea, columna));
    }
    
    private void avanzarHasta(int[] tokensDeRecuperacion) {
        Token actual;
        while (true) {
            actual = getToken(1);
            if (actual.kind == EOF) return;
            
            for (int tok : tokensDeRecuperacion) {
                if (actual.kind == tok) {
                    return;
                }
            }
            getNextToken();
        }
    }
}

// No necesitamos clase custom, usamos el enfoque de capturar caracteres inválidos directamente

class ErrorInfo {
    String tipo;
    String donde;
    String cual;
    String solucion;
    int linea;
    int columna;
    
    ErrorInfo(String tipo, String donde, String cual, String solucion, int linea, int columna) {
        this.tipo = tipo;
        this.donde = donde;
        this.cual = cual;
        this.solucion = solucion;
        this.linea = linea;
        this.columna = columna;
    }
    
    @Override
    public String toString() {
        return donde + ": " + tipo.replace("_", " ") + " " + cual + " - " + solucion;
    }
}

PARSER_END(Fax)

/* ========================
    Definición de TOKENS
    ======================== */

TOKEN: { <ENTERO: "entero"> }
TOKEN: { <REAL: "real"> }
TOKEN: { <CADENA_T: "cadena"> }
TOKEN: { <LOGICO: "logico"> }
TOKEN: { <VERDADERO: "verdadero"> }
TOKEN: { <FALSO: "falso"> }

TOKEN: { <LEER: "leer"> }
TOKEN: { <ESCRIBIR: "escribir"> }

TOKEN: { <SI: "si"> }
TOKEN: { <SINO: "sino"> }
TOKEN: { <ENTONCES: "entonces"> }

TOKEN: { <MIENTRAS: "mientras"> }
TOKEN: { <PARA: "para"> }
TOKEN: { <HACER: "hacer"> }

TOKEN: { <INICIO: "inicio"> }
TOKEN: { <FIN: "fin"> }
TOKEN: { <FUNCION: "funcion"> }
TOKEN: { <RETORNAR: "retornar"> }

TOKEN: { <SEGUN: "segun"> }
TOKEN: { <CASO: "caso"> }
TOKEN: { <DEFECTO: "defecto"> }
TOKEN: { <ROMPER: "romper"> }

TOKEN: { <AND: "&&"> }
TOKEN: { <OR: "||"> }
TOKEN: { <NOT: "!"> }

TOKEN: { <SUMA: "+"> }
TOKEN: { <RESTA: "-"> }
TOKEN: { <MULTIPLICA: "*"> }
TOKEN: { <DIVIDE: "/"> }

TOKEN: { <MENOR_IGUAL: "<="> }
TOKEN: { <MAYOR_IGUAL: ">="> }
TOKEN: { <DIFERENTE: "!="> }
TOKEN: { <IGUAL: "=="> }
TOKEN: { <MENOR: "<"> }
TOKEN: { <MAYOR: ">"> }

TOKEN: { <ASIG: "="> }

TOKEN: { <PAR_ABRE: "("> }
TOKEN: { <PAR_CIERRA: ")"> }
TOKEN: { <COR_ABRE: "["> }
TOKEN: { <COR_CIERRA: "]"> }
TOKEN: { <LLAVE_ABRE: "{"> }
TOKEN: { <LLAVE_CIERRA: "}"> }
TOKEN: { <PUNTO_COMA: ";"> }
TOKEN: { <COMA: ","> }
TOKEN: { <PUNTO: "."> }
TOKEN: { <DOS_PUNTOS: ":"> }

TOKEN: { <NUM_REAL: (["0"-"9"])+ "." (["0"-"9"])+> }
TOKEN: { <NUM_ENTERO: (["0"-"9"])+> }

TOKEN: { <CADENA: "\"" (~["\""])* "\""> }

TOKEN: { <ID: (["a"-"z","A"-"Z","_"])(["a"-"z","A"-"Z","0"-"9","_"])*> }

SKIP: { " " | "\t" | "\r" | "\n" }

/* Captura caracteres inválidos para reportar errores - Uno a uno, luego continúa */
TOKEN: {
    <CHAR_INVALIDO: ~["a"-"z","A"-"Z","_","0"-"9"," ","\t","\r","\n","(",")","{","}","[","]",";",",",".",":","=","!","<",">","+","-","*","/","&","|","\""]> 
    {
        Fax.agregarErrorLexico(matchedToken.beginLine, matchedToken.beginColumn, matchedToken.image);
    }
}

/* ========================
    REGLAS SINTÁCTICAS
    ======================== */

void Programa() :
{
    Token t;
    boolean tokenInesperadoAntesDelFin = false;
}
{
    try {
        <INICIO>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "El programa debe iniciar con 'inicio'");
        avanzarHasta(new int[]{ENTERO, REAL, CADENA_T, LOGICO, ID, SI, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR, FIN});
    }
    
    (
        LOOKAHEAD({getToken(1).kind != FIN && getToken(1).kind != EOF})
        CodigoOError()
    )*
    
    {
        t = getToken(1);
        if (t.kind != FIN && t.kind != EOF) {
            agregarError("ERROR_SINTÁCTICO", t, 
                        "Token inesperado, se esperaba 'fin'");
            tokenInesperadoAntesDelFin = true;
            while (t.kind != FIN && t.kind != EOF) {
                t = getNextToken();
                if (getToken(1).kind == FIN || getToken(1).kind == EOF) {
                    break;
                }
            }
        }
    }
    
    try {
        <FIN>
    } catch (ParseException e) {
        if (!tokenInesperadoAntesDelFin) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "El programa debe finalizar con 'fin'");
        }
    }
    
    // ← AGREGAR ESTO: Consumir y reportar tokens después de 'fin'
    {
        t = getToken(1);
        while (t.kind != EOF) {
            if (t.kind == CHAR_INVALIDO) {
                // Ya fue registrado por el TOKEN handler
            } else {
                agregarError("ERROR_SINTÁCTICO", t, 
                            "Token inesperado después de 'fin'");
            }
            t = getNextToken();
        }
    }
    
    <EOF>
}

void CodigoOError() :
{
    Token t;
}
{
    try {
        (
            LOOKAHEAD(TipoDato() <ID>)
            Declaracion()
            |
            LOOKAHEAD(2)
            Sentencia()
        )
    } catch (ParseException e) {
        t = getToken(1);
        if (t.kind != EOF && t.kind != FIN) {
            t = getNextToken();
            agregarError("ERROR_SINTÁCTICO", t, 
                        "Token inesperado, se esperaba una declaración o sentencia");
            avanzarHasta(new int[]{PUNTO_COMA, ENTERO, REAL, CADENA_T, LOGICO, ID, SI, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR, ROMPER, FIN});
            if (getToken(1).kind == PUNTO_COMA) {
                getNextToken();
            }
        }
    }
}

void Declaracion() :
{
    Token tipo, id, siguiente;
}
{
    tipo = TipoDato()
    
    try {
        id = <ID>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Falta identificador tras el tipo de dato");
        avanzarHasta(new int[]{PUNTO_COMA, ENTERO, REAL, CADENA_T, LOGICO});
        if (getToken(1).kind == PUNTO_COMA) {
            getNextToken();
        }
        return; // ← Salir temprano para evitar más errores
    }
    
    // Verificar si es vector o matriz
    (
        <COR_ABRE>
        <NUM_ENTERO>
        <COR_CIERRA>
        
        (
            <COR_ABRE>
            <NUM_ENTERO>
            <COR_CIERRA>
        )?
    )?
    
    // Inicialización opcional
    (
        <ASIG>
        try {
            Expresion()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Expresión de asignación incorrecta");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
    )?
    
    // Manejo mejorado del punto y coma
    try {
        <PUNTO_COMA>
    } catch (ParseException e) {
        siguiente = getToken(1);
        agregarError("ERROR_SINTÁCTICO", e.currentToken, 
                    "Falta punto y coma (;) después de la declaración");
        // NO consumir el siguiente token si es una palabra clave
        if (siguiente.kind != ENTERO && siguiente.kind != REAL && 
            siguiente.kind != CADENA_T && siguiente.kind != LOGICO &&
            siguiente.kind != SI && siguiente.kind != MIENTRAS &&
            siguiente.kind != PARA && siguiente.kind != FIN) {
            avanzarHasta(new int[]{PUNTO_COMA, ENTERO, REAL, CADENA_T, LOGICO, FIN});
            if (getToken(1).kind == PUNTO_COMA) {
                getNextToken();
            }
        }
        // Si el siguiente token es una palabra clave, dejarlo para el siguiente parseo
    }
}

Token TipoDato() :
{
    Token t;
}
{
    (
        t = <ENTERO> | t = <REAL> | t = <CADENA_T> | t = <LOGICO>
    )
    { return t; }
}

void Sentencia() :
{}
{
    try {
        (
            LOOKAHEAD(2) Asignacion()
            | LOOKAHEAD(2) LecturaEscritura()
            | LOOKAHEAD(2) Condicional()
            | LOOKAHEAD(2) Switch()   
            | LOOKAHEAD(2) Ciclo()
            | LOOKAHEAD(2) Retorno()
            | LOOKAHEAD(2) Romper() 
        )
    } catch (ParseException e) {
        Token t = e.currentToken.next;
        agregarError("ERROR_SINTÁCTICO", t, 
                    "Sentencia no reconocida");
        
        // Consumir el token problemático para no quedar atascado
        if (t.kind != EOF && t.kind != LLAVE_CIERRA) {
            getNextToken();
        }
        
        // Avanzar hasta punto seguro
        avanzarHasta(new int[]{PUNTO_COMA, LLAVE_CIERRA, ID, SI, SEGUN, MIENTRAS, PARA, LEER, ESCRIBIR, RETORNAR, FIN, EOF});
        
        // Consumir el punto y coma si lo encontramos
        if (getToken(1).kind == PUNTO_COMA) {
            getNextToken();
        }
    }
}

void Asignacion() :
{
    Token id, sig;
}
{
    (
        LOOKAHEAD(2) AccesoArreglo()  // ← Asignación a elemento de vector/matriz
        | <ID>                         // ← Asignación a variable simple
    )
    
    try {
        <ASIG>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Se requiere operador de asignación (=)");
        avanzarHasta(new int[]{PUNTO_COMA, NUM_ENTERO, NUM_REAL, CADENA, ID, PAR_ABRE});
    }
    
    try {
        Expresion()
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Expresión inválida en asignación");
        avanzarHasta(new int[]{PUNTO_COMA});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

void LecturaEscritura() :
{
    Token sig;
}
{
    (
        <LEER>
        try {
            <PAR_ABRE>
            (
                LOOKAHEAD(2) AccesoArreglo()  // ← NUEVO: permite leer(vector[i])
                | <ID>                         // ← O variable simple
            )
            <PAR_CIERRA>
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Formato incorrecto: debe ser leer(variable);");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
        
        {
            sig = getToken(1);
            if (sig.kind != PUNTO_COMA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
            } else {
                getNextToken();
            }
        }
    )
    |
    (
        <ESCRIBIR>
        try {
            <PAR_ABRE>
            Expresion()
            ( <COMA> Expresion() )*
            <PAR_CIERRA>
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en sintaxis de 'escribir'");
            avanzarHasta(new int[]{PUNTO_COMA});
        }
        
        {
            sig = getToken(1);
            if (sig.kind != PUNTO_COMA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
            } else {
                getNextToken();
            }
        }
    )
}

void Condicional() :
{
    Token sig;
}
{
    <SI>
    
    try {
        <PAR_ABRE>
        ExpresionLogica()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Condición mal formada en 'si'");
        avanzarHasta(new int[]{ENTONCES, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != ENTONCES) {
            agregarError("ERROR_SINTÁCTICO", sig, "Falta 'entonces' tras la condición");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD(2)
        <SINO>
        
        {
            sig = getToken(1);
            if (sig.kind != LLAVE_ABRE) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
            } else {
                getNextToken();
            }
        }
        
        (
            LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
            Sentencia()
        )*
        
        {
            sig = getToken(1);
            if (sig.kind != LLAVE_CIERRA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
            } else {
                getNextToken();
            }
        }
    )?
}

void Ciclo() :
{}
{
    CicloMientras()
    | CicloPara()
}

void CicloMientras() :
{
    Token sig;
}
{
    <MIENTRAS>
    
    try {
        <PAR_ABRE>
        ExpresionLogica()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Condición incorrecta en 'mientras'");
        avanzarHasta(new int[]{HACER, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != HACER) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba 'hacer'");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
}

void CicloPara() :
{
    Token sig;
}
{
    <PARA>
    
    try {
        <PAR_ABRE>
        <ID> <ASIG> Expresion() <PUNTO_COMA>
        ExpresionLogica() <PUNTO_COMA>
        <ID> <ASIG> Expresion()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Estructura incorrecta en ciclo 'para'");
        avanzarHasta(new int[]{HACER, LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != HACER) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba 'hacer'");
        } else {
            getNextToken();
        }
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
}

void Retorno() :
{
    Token sig;
}
{
    <RETORNAR>
    
    try {
        Expresion()
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Expresión de retorno inválida");
        avanzarHasta(new int[]{PUNTO_COMA});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

void Romper() :
{
    Token sig;
}
{
    <ROMPER>
    
    {
        sig = getToken(1);
        if (sig.kind != PUNTO_COMA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
        } else {
            getNextToken();
        }
    }
}

void Expresion() :
{}
{
    ExpresionLogica()
}

void ExpresionLogica() :
{}
{
    ExpresionRelacional()
    (
        (<AND> | <OR>)
        try {
            ExpresionRelacional()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en operación lógica");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA});
        }
    )*
}

void ExpresionRelacional() :
{}
{
    ExpresionAritmetica()
    (
        (<MENOR> | <MAYOR> | <MENOR_IGUAL> | <MAYOR_IGUAL> | <IGUAL> | <DIFERENTE>)
        try {
            ExpresionAritmetica()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en comparación");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, AND, OR});
        }
    )?
}

void ExpresionAritmetica() :
{}
{
    Termino()
    (
        (<SUMA> | <RESTA>)
        try {
            Termino()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en operación aritmética");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA});
        }
    )*
}

void Termino() :
{}
{
    Factor()
    (
        (<MULTIPLICA> | <DIVIDE>)
        try {
            Factor()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Error en multiplicación/división");
            avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, SUMA, RESTA});
        }
    )*
}

void Factor() :
{}
{
    try {
        (
            <NUM_ENTERO>
            | <NUM_REAL>
            | <CADENA>
            | <VERDADERO>
            | <FALSO>
            | LOOKAHEAD(2) AccesoArreglo()  // ← NUEVO
            | <ID>
            | <PAR_ABRE> Expresion() <PAR_CIERRA>
            | <NOT> Factor()
        )
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Factor no válido");
        avanzarHasta(new int[]{PUNTO_COMA, PAR_CIERRA, LLAVE_CIERRA, SUMA, RESTA, MULTIPLICA, DIVIDE});
    }
}

// Nueva regla para acceso a vectores y matrices
void AccesoArreglo() :
{
    Token sig;
}
{
    <ID>
    <COR_ABRE>
    try {
        Expresion()
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Índice inválido en vector/matriz");
        avanzarHasta(new int[]{COR_CIERRA});
    }
    <COR_CIERRA>
    
    // Segunda dimensión (opcional, para matrices)
    (
        LOOKAHEAD(2)
        <COR_ABRE>
        try {
            Expresion()
        } catch (ParseException e) {
            agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                        "Índice inválido en matriz");
            avanzarHasta(new int[]{COR_CIERRA});
        }
        <COR_CIERRA>
    )?
}

void Switch() :
{
    Token sig;
}
{
    <SEGUN>
    
    try {
        <PAR_ABRE>
        Expresion()
        <PAR_CIERRA>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Expresión mal formada en 'segun'");
        avanzarHasta(new int[]{LLAVE_ABRE});
    }
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_ABRE) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '{'");
        } else {
            getNextToken();
        }
    }
    
    (
        LOOKAHEAD(2)
        Caso()
    )*
    
    (
        LOOKAHEAD(2)
        CasoDefecto()
    )?
    
    {
        sig = getToken(1);
        if (sig.kind != LLAVE_CIERRA) {
            agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba '}'");
        } else {
            getNextToken();
        }
    }
}

void Caso() :
{
    Token sig;
}
{
    <CASO>
    
    try {
        Expresion()
        <DOS_PUNTOS>
    } catch (ParseException e) {
        agregarError("ERROR_SINTÁCTICO", e.currentToken.next, 
                    "Formato incorrecto en 'caso'");
        avanzarHasta(new int[]{DOS_PUNTOS, LLAVE_ABRE});
    }
    
    (
        LOOKAHEAD({getToken(1).kind != CASO && getToken(1).kind != DEFECTO && 
                   getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
    
    (
        LOOKAHEAD(2)
        <ROMPER>
        {
            sig = getToken(1);
            if (sig.kind != PUNTO_COMA) {
                agregarError("ERROR_SINTÁCTICO", sig, "Se esperaba punto y coma (;)");
            } else {
                getNextToken();
            }
        }
    )?
}

void CasoDefecto() :
{}
{
    <DEFECTO>
    <DOS_PUNTOS>
    
    (
        LOOKAHEAD({getToken(1).kind != LLAVE_CIERRA && getToken(1).kind != EOF})
        Sentencia()
    )*
}

